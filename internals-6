

File: internals,  Node: Registers,  Next: Register Classes,  Prev: Storage Layout,  Up: Machine Macros

Register Usage
==============

`FIRST_PSEUDO_REGISTER'
     Number of hardware registers known to the compiler.  They receive
     numbers 0 through `FIRST_PSEUDO_REGISTER-1'; thus, the first pseudo
     register's number really is assigned the number `FIRST_PSEUDO_REGISTER'.

`FIXED_REGISTERS'
     An initializer that says which registers are used for fixed purposes
     all throughout the compiled code and are therefore not available for
     general allocation.  These would include the stack pointer, the frame
     pointer, the program counter on machines where that is considered one
     of the addressable registers, and any other numbered register with a
     standard use.

     This information is expressed as a sequence of numbers, separated by
     commas and surrounded by braces.  The Nth number is 1 if register N is
     fixed, 0 otherwise.

     The table initialized from this macro, and the table initialized by
     the following one, may be overridden at run time either automatically,
     by the actions of the macro `CONDITIONAL_REGISTER_USAGE', or by the
     user with the command options `-ffixed-REG', `-fcall-used-REG' and
     `-fcall-saved-REG'.

`CALL_USED_REGISTERS'
     Like `FIXED_REGISTERS' but has 1 for each register that is clobbered
     (in general) by function calls as well as for fixed registers.  This
     macro therefore identifies the registers that are not available for
     general allocation of values that must live across function calls.

     If a register has 0 in `CALL_USED_REGISTERS', the compiler
     automatically saves it on function entry and restores it on function
     exit, if the register is used within the function.

`CONDITIONAL_REGISTER_USAGE'
     Zero or more C statements that may conditionally modify two variables
     `fixed_regs' and `call_used_regs' (both of type `char []') after they
     have been initialized from the two preceding macros.

     This is necessary in case the fixed or call-clobbered registers depend
     on target flags.

     You need not define this macro if it has no work to do.

`HARD_REGNO_REGS (REGNO, MODE)'
     A C expression for the number of consecutive hard registers, starting
     at register number REGNO, required to hold a value of mode MODE.

     On a machine where all registers are exactly one word, a suitable
     definition of this macro is

          #define HARD_REGNO_NREGS(REGNO, MODE)            \
             ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \
              / UNITS_PER_WORD))

`HARD_REGNO_MODE_OK (REGNO, MODE)'
     A C expression that is nonzero if it is permissible to store a value
     of mode MODE in hard register number REGNO (or in several registers
     starting with that one).  For a machine where all registers are
     equivalent, a suitable definition is

          #define HARD_REGNO_MODE_OK(REGNO, MODE) 1

     It is not necessary for this macro to check for fixed register numbers
     because the allocation mechanism considers them to be always occupied.

     Many machines have special registers for floating point arithmetic. 
     Often people assume that floating point machine modes are allowed only
     in floating point registers.  This is not true.  Any registers that
     can hold integers can safely *hold* a floating point machine mode,
     whether or not floating arithmetic can be done on it in those registers.

     The true significance of special floating registers is rather than
     non-floating-point machine modes *may not* go in those registers. 
     This is true if the floating registers normalize any value stored in
     them, because storing a non-floating value there would garble it.  If
     the floating registers do not automatically normalize, if you can
     store any bit pattern in one and retrieve it unchanged without a trap,
     then any machine mode may go in a floating register and this macro
     should say so.

     Sometimes there are floating registers that are especially slow to
     access, so that it is better to store a value in a stack frame than in
     such a register if floating point arithmetic is not being done.  As
     long as the floating registers are not in class `GENERAL_REGS', they
     will not be used unless some insn's constraint asks for one.

     It is obligatory to support floating point `move' instructions into
     and out of general registers, because unions and structures (which
     have modes `SImode' or `DImode') can be in those registers and they
     may have floating point members.

`MODES_TIEABLE_P (MODE1, MODE2)'
     A C expression that is nonzero if it is desirable to choose register
     allocation so as to avoid move instructions between a value of mode
     MODE1 and a value of mode MODE2.

     If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R, MODE2)'
     are ever different for any R, then `MODES_TIEABLE_P (MODE1, MODE2)'
     must be zero.

`PC_REGNUM'
     If the program counter has a register number, define this as that
     register number.  Otherwise, do not define it.

`STACK_POINTER_REGNUM'
     The register number of the stack pointer register, which must also be
     a fixed register according to `FIXED_REGISTERS'.  On many machines,
     the hardware determines which register this is.

`FRAME_POINTER_REGNUM'
     The register number of the frame pointer register, which is used to
     access automatic variables in the stack frame.  On some machines, the
     hardware determines which register this is.  On other machines, you
     can choose any register you wish for this purpose.

`FRAME_POINTER_REQUIRED'
     A C expression which is nonzero if a function must have and use a
     frame pointer.  This expression is evaluated in the reload pass, in
     the function `reload', and it can in principle examine the current
     function and decide according to the facts, but on most machines the
     constant 0 or the constant 1 suffices.  Use 0 when the machine allows
     code to be generated with no frame pointer, and doing so saves some
     time or space.  Use 1 when there is no possible advantage to avoiding
     a frame pointer.

     In certain cases, the compiler does not know how to do without a frame
     pointer.  The compiler recognizes those cases and automatically gives
     the function a frame pointer regardless of what
     `FRAME_POINTER_REQUIRED' says.  You don't need to worry about them.

     In a function that does not require a frame pointer, the frame pointer
     register can be allocated for ordinary usage, provided it is not
     marked as a fixed register.  See `FIXED_REGISTERS' for more information.

`ARG_POINTER_REGNUM'
     The register number of the arg pointer register, which is used to
     access the function's argument list.  On some machines, this is the
     same as the frame pointer register.  On some machines, the hardware
     determines which register this is.  On other machines, you can choose
     any register you wish for this purpose.  It must in any case be a
     fixed register according to `FIXED_REGISTERS'.

`STATIC_CHAIN_REGNUM'
     The register number used for passing a function's static chain
     pointer.  This is needed for languages such as Pascal and Algol where
     functions defined within other functions can access the local
     variables of the outer functions; it is not currently used because C
     does not provide this feature.

     The static chain register need not be a fixed register.

`STRUCT_VALUE_REGNUM'
     When a function's value's mode is `BLKmode', the value is not returned
     according to `FUNCTION_VALUE'.  Instead, the caller passes the address
     of a block of memory in which the value should be stored. 
     `STRUCT_VALUE_REGNUM' is the register in which this address is passed.


File: internals,  Node: Register Classes,  Next: Stack Layout,  Prev: Registers,  Up: Machine Macros

Register Classes
================

On many machines, the numbered registers are not all equivalent.  For
example, certain registers may not be allowed for indexed addressing;
certain registers may not be allowed in some instructions.  These machine
restrictions are described to the compiler using "register classes".

You define a number of register classes, giving each one a name and saying
which of the registers belong to it.  Then you can specify register classes
that are allowed as operands to particular instruction patterns.

In general, each register will belong to several classes.  In fact, one
class must be named `ALL_REGS' and contain all the registers.  Another
class must be named `NO_REGS' and contain no registers.  Often the union of
two classes will be another class; however, this is not required.

One of the classes must be named `GENERAL_REGS'.  There is nothing terribly
special about the name, but the operand constraint letters `r' and `g'
specify this class.  If `GENERAL_REGS' is the same as `ALL_REGS', just
define it as a macro which expands to `ALL_REGS'.

The way classes other than `GENERAL_REGS' are specified in operand
constraints is through machine-dependent operand constraint letters.  You
can define such letters to correspond to various classes, then use them in
operand constraints.

You should define a class for the union of two classes whenever some
instruction allows both classes.  For example, if an instruction allows
either a floating-point (coprocessor) register or a general register for a
certain operand, you should define a class `FLOAT_OR_GENERAL_REGS' which
includes both of them.  Otherwise you will get suboptimal code.

You must also specify certain redundant information about the register
classes: for each class, which classes contain it and which ones are
contained in it; for each pair of classes, the largest class contained in
their union.

`enum reg_class'
     An enumeral type that must be defined with all the register class
     names as enumeral values.  `NO_REGS' must be first.  `ALL_REGS' must
     be the last register class, followed by one more enumeral value,
     `LIM_REG_CLASSES', which is not a register class but rather tells how
     many classes there are.

     Each register class has a number, which is the value of casting the
     class name to type `int'.  The number serves as an index in many of
     the tables described below.

`REG_CLASS_NAMES'
     An initializer containing the names of the register classes as C
     string constants.  These names are used in writing some of the
     debugging dumps.

`REG_CLASS_CONTENTS'
     An initializer containing the contents of the register classes, as
     integers which are bit masks.  The Nth integer specifies the contents
     of class N.  The way the integer MASK is interpreted is that register
     R is in the class if `MASK & (1 << R)' is 1.

     When the machine has more than 32 registers, an integer does not
     suffice.  Then the integers are replaced by sub-initializers, braced
     groupings containing several integers.  Each sub-initializer must be
     suitable as an initializer for the type `HARD_REG_SET' which is
     defined in `hard-reg-set.h'.

`REGNO_REG_CLASS (REGNO)'
     A C expression whose value is a register class containing hard
     regiSTER REGNO.  In general there is more that one such class; choose
     a class which is "minimal", meaning that no smaller class also
     contains the register.

`INDEX_REG_CLASS'
     A macro whose definition is the name of the class to which a valid
     index register must belong.

`REG_CLASS_FROM_LETTER (CHAR)'
     A C expression which defines the machine-dependent operand constraint
     letters for register classes.  If CHAR is such a letter, the value
     should be the register class corresponding to it.  Otherwise, the
     value should be `NO_REGS'.

`REGNO_OK_FOR_BASE_P (NUM)'
     A C expression which is nonzero if register number NUM is suitable for
     use as a base register in operand addresses.  It may be either a
     suitable hard register or a pseudo register that has been allocated
     such a hard register.

`REGNO_OK_FOR_INDEX_P (NUM)'
     A C expression which is nonzero if register number NUM is suitable for
     use as an index register in operand addresses.  It may be either a
     suitable hard register or a pseudo register that has been allocated
     such a hard register.

     The difference between an index register and a base register is that
     the index register may be scaled.  If an address involves the sum of
     two registers, neither one of them scaled, then either one may be
     labeled the ``base'' and the other the ``index''; but whichever
     labeling is used must fit the machine's constraints of which registers
     may serve in each capacity.  The compiler will try both labelings,
     looking for one that is valid, and reload one or both registers only
     if neither labeling works.

`PREFERRED_RELOAD_CLASS (X, CLASS)'
     A C expression that places additional restrictions on the register
     class to use when it is necessary to copy value X into a register in
     class CLASS.  The value is a register class; perhaps CLASS, or perhaps
     another, smaller class.  CLASS is always safe as a value.  In fact,
     the definition

          #define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS

     is always safe.  However, sometimes returning a more restrictive class
     makes better code.  For example, on the 68000, when X is an integer
     constant that is in range for a `moveq' instruction, the value of this
     macro is always `DATA_REGS' as long as CLASS includes the data
     registers.  Requiring a data register guarantees that a `moveq' will
     be used.

`CLASS_MAX_NREGS (CLASS, MODE)'
     A C expression for the maximum number of consecutive registers of
     cLASS CLASS needed to hold a value of mode MODE.

     This is closely related to the macro `HARD_REGNO_NREGS'.  In fact, the
     value of the macro `CLASS_MAX_NREGS (CLASS, MODE)' should be the
     maximum value of `HARD_REGNO_NREGS (REGNO, MODE)' for all REGNO values
     in the class CLASS.

     This macro helps control the handling of multiple-word values in the
     reload pass.

Two other special macros describe which constants fit which constraint
letters.

`CONST_OK_FOR_LETTER_P (VALUE, C)'
     A C expression that defines the machine-dependent operand constraint
     letters that specify particular ranges of integer values.  If C is one
     of those letters, the expression should check that VALUE, an integer,
     is in the appropriate range and return 1 if so, 0 otherwise.  If C is
     not one of those letters, the value should be 0 regardless of VALUE.

`CONST_DOUBLE_OK_FOR_LETTER_P (VALUE, C)'
     A C expression that defines the machine-dependent operand constraint
     letters that specify particular ranges of floating values.  If C is
     one of those letters, the expression should check that VALUE, an RTX
     of code `const_double', is in the appropriate range and return 1 if
     so, 0 otherwise.  If C is not one of those letters, the value should
     be 0 regardless of VALUE.


File: internals,  Node: Stack Layout,  Next: Library Names,  Prev: Register Classes,  Up: Machine Macros

Describing Stack Layout
=======================

`STACK_GROWS_DOWNWARD'
     Define this macro if pushing a word onto the stack moves the stack
     pointer to a smaller address.

     When we say, ``define this macro if ...,'' it means that the compiler
     checks this macro only with `#ifdef' so the precise definition used
     does not matter.

`FRAME_GROWS_DOWNWARD'
     Define this macro if the addresses of local variable slots are at
     negative offsets from the frame pointer.

`STARTING_FRAME_OFFSET'
     Offset from the frame pointer to the first local variable slot to be
     allocated.

     If `FRAME_GROWS_DOWNWARD', the next slot's offset is found by
     subtracting the length of the first slot from `STARTING_FRAME_OFFSET'.
      Otherwise, it is found by adding the length of the first slot to the
     value `STARTING_FRAME_OFFSET'.

`PUSH_ROUNDING (NPUSHED)'
     A C expression that is the number of bytes actually pushed onto the
     stack when an instruction attempts to push NPUSHED bytes.

     If the target machine does not have a push instruction, do not define
     this macro.  That directs GNU CC to use an alternate strategy: to
     allocate the entire argument block and then store the arguments into it.

     On some machines, the definition

          #define PUSH_ROUNDING(BYTES) (BYTES)

     will suffice.  But on other machines, instructions that appear to push
     one byte actually push two bytes in an attempt to maintain alignment. 
     Then the definition should be

          #define PUSH_ROUNDING(BYTES) (((BYTES) + 1) & ~1)

`FIRST_PARM_OFFSET'
     Offset from the argument pointer register to the first argument's
     address.

`RETURN_POPS_ARGS (FUNTYPE)'
     A C expression that should be 1 if a function pops its own arguments
     on returning, or 0 if the function pops no arguments and the caller
     must therefore pop them all after the function returns.

     FUNTYPE is a C variable whose value is a tree node that describes the
     function in question.  Normally it is a node of type `FUNCTION_TYPE'
     that describes the data type of the function.  From this it is
     possible to obtain the data types of the value and arguments (if known).

     When a call to a library function is being considered, FUNTYPE will
     contain an identifier node for the library function.  Thus, if you
     need to distinguish among various library functions, you can do so by
     their names.  Note that ``library function'' in this context means a
     function used to perform arithmetic, whose name is known specially in
     the compiler and was not mentioned in the C code being compiled.

     On the Vax, all functions always pop their arguments, so the
     definition of this macro is 1.  On the 68000, using the standard
     calling convention, no functions pop their arguments, so the value of
     the macro is always 0 in this case.  But an alternative calling
     convention is available in which functions that take a fixed number of
     arguments pop them but other functions (such as `printf') pop nothing
     (the caller pops all).  When this convention is in use, FUNTYPE is
     examined to determine whether a function takes a fixed number of
     arguments.

`FUNCTION_VALUE (VALTYPE, FUNC)'
     A C expression to create an RTX representing the place where a
     function returns a value of data type VALTYPE.  VALTYPE is a tree node
     representing a data type.  Write `TYPE_MODE (VALTYPE)' to get the
     machine mode used to represent that type.  On many machines, only the
     mode is relevant.  (Actually, on most machines, scalar values are
     returned in the same place regardless of mode).

     If the precise function being called is known, FUNC is a tree node
     (`FUNCTION_DECL') for it; otherwise, FUNC is a null pointer.  This
     makes it possible to use a different value-returning convention for
     specific functions when all their calls are known.

`FUNCTION_OUTGOING_VALUE (VALTYPE, FUNC)'
     Define this macro if the target machine has ``register windows'' so
     that the register in which a function returns its value is not the
     same as the one in which the caller sees the value.

     For such machines, `FUNCTION_VALUE' computes the register in which the
     caller will see the value, and `FUNCTION_OUTGOING_VALUE' should be
     defined in a similar fashion to tell the function where to put the
     value.

     If `FUNCTION_OUTGOING_VALUE' is not defined, `FUNCTION_VALUE' serves
     both purposes.

`LIBCALL_VALUE (MODE)'
     A C expression to create an RTX representing the place where a library
     function returns a value of mode MODE.  If the precise function being
     called is known, FUNC is a tree node (`FUNCTION_DECL') for it;
     otherwise, FUNC is a null pointer.  This makes it possible to use a
     different value-returning convention for specific functions when all
     their calls are known.

     Note that ``library function'' in this context means a compiler
     support routine, used to perform arithmetic, whose name is known
     specially by the compiler and was not mentioned in the C code being
     compiled.

`FUNCTION_VALUE_REGNO_P (REGNO)'
     A C expression that is nonzero if REGNO is the number of a hard
     register in which function values are sometimes returned.

     A register whose use for returning values is limited to serving as the
     second of a pair (for a value of type `double', say) need not be
     recognized by this macro.  So for most machines, this definition
     suffices:

          #define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)

`FUNCTION_ARG (CUM, MODE, TYPE, NAMED)'
     A C expression that controls whether a function argument is passed in
     a register, and which register.

     The arguments are CUM, which summarizes all the previous arguments;
     MODE, the machine mode of the argument; TYPE, the data type of the
     argument as a tree node or 0 if that is not known (which happens for C
     support library functions); and NAMED, which is 1 for an ordinary
     argument and 0 for nameless arguments that correspond to `...' in the
     called function's prototype.

     The value of the expression should either be a `reg' RTX for the hard
     register in which to pass the argument, or zero to pass the argument
     on the stack.

     For the Vax and 68000, where normally all arguments are pushed, zero
     suffices as a definition.

`FUNCTION_INCOMING_ARG (CUM, MODE, TYPE, NAMED)'
     Define this macro if the target machine has ``register windows'', so
     that the register in which a function sees an arguments is not
     necessarily the same as the one in which the caller passed the argument.

     For such machines, `FUNCTION_ARG' computes the register in which the
     caller passes the value, and `FUNCTION_INCOMING_ARG' should be defined
     in a similar fashion to tell the function being called where the
     arguments will arrive.

     If `FUNCTION_INCOMING_ARG' is not defined, `FUNCTION_ARG' serves both
     purposes.

`FUNCTION_ARG_PARTIAL_NREGS (CUM, MODE, TYPE, NAMED)'
     A C expression for the number of words, at the beginning of an
     argument, must be put in registers.  The value must be zero for
     arguments that are passed entirely in registers or that are entirely
     pushed on the stack.

     On some machines, certain arguments must be passed partially in
     registers and partially in memory.  On these machines, typically the
     first N words of arguments are passed in registers, and the rest on
     the stack.  If a multi-word argument (a `double' or a structure)
     crosses that boundary, its first few words must be passed in registers
     and the rest must be pushed.  This macro tells the compiler when this
     occurs, and how many of the words should go in registers.

     `FUNCTION_ARG' for these arguments should return the first register to
     be used by the caller for this argument; likewise
     `FUNCTION_INCOMING_ARG', for the called function.

`CUMULATIVE_ARGS'
     A C type for declaring a variable that is used as the first argument
     of `FUNCTION_ARG' and other related values.  For some target machines,
     the type `int' suffices and can hold the number of bytes of argument
     so far.

`INIT_CUMULATIVE_ARGS (CUM)'
     A C statement (sans semicolon) for initializing the variable CUM for
     the state at the beginning of the argument list.  The variable has
     type `CUMULATIVE_ARGS'.

`FUNCTION_ARG_ADVANCE (CUM, MODE, TYPE, NAMED)'
     Update the summarizer variable CUM to advance past an argument in the
     argument list.  The values MODE, TYPE and NAMED describe that
     argument.  Once this is done, the variable CUM is suitable for
     analyzing the *following* argument with `FUNCTION_ARG', etc.

`FUNCTION_ARG_REGNO_P (REGNO)'
     A C expression that is nonzero if REGNO is the number of a hard
     register in which function arguments are sometimes passed.  This does
     *not* include implicit arguments such as the static chain and the
     structure-value address.  On many machines, no registers can be used
     for this purpose since all function arguments are pushed on the stack.

`FUNCTION_PROLOGUE (FILE, SIZE)'
     A C compound statement that outputs the assembler code for entry to a
     function.  The prologue is responsible for setting up the stack frame,
     initializing the frame pointer register, saving registers that must be
     saved, and allocating SIZE additional bytes of storage for the local
     variables.  SIZE is an integer.  FILE is a stdio stream to which the
     assembler code should be output.

     The label for the beginning of the function need not be output by this
     macro.  That has already been done when the macro is run.

     To determine which registers to save, the macro can refer to the array
     `regs_ever_live': element R is nonzero if hard register R is used
     anywhere within the function.  This implies the function prologue
     should save register R, but not if it is one of the call-used registers.

     On machines where functions may or may not have frame-pointers, the
     function entry code must vary accordingly; it must set up the frame
     pointer if one is wanted, and not otherwise.  To determine whether a
     frame pointer is in wanted, the macro can refer to the variable
     `frame_pointer_needed'.  The variable's value will be 1 at run time in
     a function that needs a frame pointer.

`FUNCTION_PROFILER (FILE, LABELNO)'
     A C statement or compound statement to output to FILE some assembler
     code to call the profiling subroutine `mcount'.  Before calling, the
     assembler code must load the address of a counter variable into a
     register where `mcount' expects to find the address.  The name of this
     variable is `LP' followed by the number LABELNO, so you would generate
     the name using `LP%d' in a `fprintf'.

     The details of how the address should be passed to `mcount' are
     determined by your operating system environment, not by GNU CC.  To
     figure them out, compile a small program for profiling using the
     system's installed C compiler and look at the assembler code that
     results.

`EXIT_IGNORES_STACK'
     Define this macro as a C expression that is nonzero if the return
     instruction or the function epilogue ignores the value of the stack
     pointer; in other words, if it is safe to delete an instruction to
     adjust the stack pointer before a return from the function.

     Note that this macro's value is relevant only for for which frame
     pointers are maintained.  It is never possible to delete a final stack
     adjustment in a function that has no frame pointer, and the compiler
     knows this regardless of `EXIT_IGNORES_STACK'.

`FUNCTION_EPILOGUE (FILE, SIZE)'
     A C compound statement that outputs the assembler code for exit from a
     function.  The epilogue is responsible for restoring the saved
     registers and stack pointer to their values when the function was
     called, and returning control to the caller.  This macro takes the
     same arguments as the macro `FUNCTION_PROLOGUE', and the registers to
     restore are determined from `regs_ever_live' and `CALL_USED_REGISTERS'
     in the same way.

     On some machines, there is a single instruction that does all the work
     of returning from the function.  On these machines, give that
     instruction the name `return' and do not define the macro
     `FUNCTION_EPILOGUE' at all.

     On machines where functions may or may not have frame-pointers, the
     function exit code must vary accordingly.  Sometimes the code for
     these two cases is completely different.  To determine whether a frame
     pointer is in wanted, the macro can refer to the variable
     `frame_pointer_needed'.  The variable's value will be 1 at run time in
     a function that needs a frame pointer.

     On some machines, some functions pop their arguments on exit while
     others leave that for the caller to do.  For example, the 68020 when
     given `-mrtd' pops arguments in functions that take a fixed number of
     arguments.

     Your definition of the macro `RETURN_POPS_ARGS' decides which
     functions pop their own arguments.  `FUNCTION_EPILOGUE' needs to know
     what was decided.  The variable `current_function_pops_args' is
     nonzero if the function should pop its own arguments.  If so, use the
     variable `current_function_args_size' as the number of bytes to pop.

`FIX_FRAME_POINTER_ADDRESS (ADDR, DEPTH)'
     A C compound statement to alter a memory address that uses the frame
     pointer register so that it uses the stack pointer register instead. 
     This must be done in the instructions that load parameter values into
     registers, when the reload pass determines that a frame pointer is not
     necessary for the function.  ADDR will be a C variable name, and the
     updated address should be stored in that variable.  DEPTH will be the
     current depth of stack temporaries (number of bytes of arguments
     currently pushed).  The change in offset between a
     frame-pointer-relative address and a stack-pointer-relative address
     must include DEPTH.

     Even if your machine description specifies there will always be a
     frame pointer in the frame pointer register, you must still define
     `FIX_FRAME_POINTER_ADDRESS', but the definition will never be executed
     at run time, so it may be empty.


File: internals,  Node: Library Names,  Next: Addressing Modes,  Prev: Stack Layout,  Up: Machine Macros

Library Subroutine Names
========================

`UDIVSI3_LIBCALL'
     A C string constant giving the name of the function to call for
     division of a full-word by a full-word.  If you do not define this
     macro, the default name is used, which is `_udivsi3', a function
     defined in `gnulib'.

`UMODSI3_LIBCALL'
     A C string constant giving the name of the function to call for the
     remainder in division of a full-word by a full-word.  If you do not
     define this macro, the default name is used, which is `_umodsi3', a
     function defined in `gnulib'.

`TARGET_MEM_FUNCTIONS'
     Define this macro if GNU CC should generate calls to the System V (and
     ANSI C) library functions `memcpy' and `memset' rather than the BSD
     functions `bcopy' and `bzero'.


File: internals,  Node: Addressing Modes,  Next: Misc,  Prev: Library Names,  Up: Machine Macros

Addressing Modes
================

`HAVE_POST_INCREMENT'
     Define this macro if the machine supports post-increment addressing.

`HAVE_PRE_INCREMENT'
`HAVE_POST_DECREMENT'
`HAVE_PRE_DECREMENT'
     Similar for other kinds of addressing.

`CONSTANT_ADDRESS_P (X)'
     A C expression that is 1 if the RTX X is a constant whose value is an
     integer.  This includes integers whose values are not explicitly
     known, such as `symbol_ref' and `label_ref' expressions and `const'
     arithmetic expressions.

     On most machines, this can be defined as `CONSTANT_P (X)', but a few
     machines are more restrictive in which constant addresses are supported.

`MAX_REGS_PER_ADDRESS'
     A number, the maximum number of registers that can appear in a valid
     memory address.

`GO_IF_LEGITIMATE_ADDRESS (MODE, X, LABEL)'
     A C compound statement with a conditional `goto LABEL;' executed if X
     (an RTX) is a legitimate memory address on the target machine for a
     memory operand of mode MODE.

     It usually pays to define several simpler macros to serve as
     subroutines for this one.  Otherwise it may be too complicated to
     understand.

     This macro must exist in two variants: a strict variant and a
     non-strict one.  The strict variant is used in the reload pass.  It
     must be defined so that any pseudo-register that has not been
     allocated a hard register is considered a memory reference.  In
     contexts where some kind of register is required, a pseudo-register
     with no hard register must be rejected.

     The non-strict variant is used in other passes.  It must be defined to
     accept all pseudo-registers in every context where some kind of
     register is required.

     Compiler source files that want to use the strict variant of this
     macro define the macro `REG_OK_STRICT'.  You should use an `#ifdef
     REG_OK_STRICT' conditional to define the strict variant in that case
     and the non-strict variant otherwise.

     Typically among the subroutines used to define
     `GO_IF_LEGITIMATE_ADDRESS' are subroutines to check for acceptable
     registers for various purposes (one for base registers, one for index
     registers, and so on).  Then only these subroutine macros need have
     two variants; the higher levels of macros may be the same whether
     strict or not.

`LEGITIMIZE_ADDRESS (X, OLDX, MODE, WIN)'
     A C compound statement that attempts to replace X with a valid memory
     address for an operand of mode MODE.  WIN will be a C statement label
     elsewhere in the code; the macro definition may use

          GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN);

     to avoid further processing if the address has become legitimate.

     X will always be the result of a call to `break_out_memory_refs', and
     OLDX will be the operand that was given to that function to produce X.

     The code generated by this macro should not alter the substructure of
     X.  If it transforms X into a more legitimate form, it should assign X
     (which will always be a C variable) a new value.

     It is not necessary for this macro to come up with a legitimate
     address.  The compiler has standard ways of doing so in all cases.  In
     fact, it is safe for this macro to do nothing.  But often a
     machine-dependent strategy can generate better code.

`GO_IF_MODE_DEPENDENT_ADDRESS (ADDR, LABEL)'
     A C statement or compound statement with a conditional `goto LABEL;'
     executed if memory address X (an RTX) can have different meanings
     depending on the machine mode of the memory reference it is used for.

     Autoincrement and autodecrement addresses typically have
     mode-dependent effects because the amount of the increment or
     decrement is the size of the operand being addressed.  Some machines
     have other mode-dependent addresses.  Many RISC machines have no
     mode-dependent addresses.

     You may assume that ADDR is a valid address for the machine.

`LEGITIMATE_CONSTANT_P (X)'
     A C expression that is nonzero if X is a legitimate constant for an
     immediate operand on the target machine.  You can assume that either X
     is a `const_double' or it satisfies `CONSTANT_P', so you need not
     check these things.  In fact, `1' is a suitable definition for this
     macro on machines where any `const_double' is valid and anything
     `CONSTANT_P' is valid.


File: internals,  Node: Misc,  Next: Condition Code,  Prev: Addressing Modes,  Up: Machine Macros

Miscellaneous Parameters
========================

`CASE_VECTOR_MODE'
     An alias for a machine mode name.  This is the machine mode that
     elements of a jump-table should have.

`CASE_VECTOR_PC_RELATIVE'
     Define this macro if jump-tables should contain relative addresses.

`CASE_DROPS_THROUGH'
     Define this if control falls through a `case' insn when the index
     value is out of range.  This means the specified default-label is
     actually ignored by the `case' insn proper.

`IMPLICIT_FIX_EXPR'
     An alias for a tree code that should be used by default for conversion
     of floating point values to fixed point.  Normally, `FIX_ROUND_EXPR'
     is used.

`FIXUNS_TRUNC_LIKE_FIX_TRUNC'
     Define this macro if the same instructions that convert a floating
     point number to a signed fixed point number also convert validly to an
     unsigned one.

`EASY_DIV_EXPR'
     An alias for a tree code that is the easiest kind of division to
     compile code for in the general case.  It may be `TRUNC_DIV_EXPR',
     `FLOOR_DIV_EXPR', `CEIL_DIV_EXPR' or `ROUND_DIV_EXPR'.  These four
     division operators differ in how they round the result to an integer. 
     `EASY_DIV_EXPR' is used when it is permissible to use any of those
     kinds of division and the choice should be made on the basis of
     efficiency.

`DEFAULT_SIGNED_CHAR'
     An expression whose value is 1 or 0, according to whether the type
     `char' should be signed or unsigned by default.  The user can always
     override this default with the options `-fsigned-char' and
     `-funsigned-char'.

`SCCS_DIRECTIVE'
     Define this if the preprocessor should ignore `#sccs' directives with
     no error message.

`MOVE_MAX'
     The maximum number of bytes that a single instruction can move quickly
     from memory to memory.

`INT_TYPE_SIZE'
     A C expression for the size in bits of the type `int' on the target
     machine.

`SLOW_BYTE_ACCESS'
     Define this macro as a C expression which is nonzero if accessing less
     than a word of memory (i.e. a `char' or a `short') is slow (requires
     more than one instruction).

`SLOW_ZERO_EXTEND'
     Define this macro if zero-extension (of a `char' or `short' to an
     `int') can be done faster if the destination is a register that is
     known to be zero.

     If you define this macro, you must have instruction patterns that
     recognize RTL structures like this:

          (set (strict-low-part (subreg:QI (reg:SI ...) 0)) ...)

     and likewise for `HImode'.

`SHIFT_COUNT_TRUNCATED'
     Define this macro if shift instructions ignore all but the lowest few
     bits of the shift count.  It implies that a sign-extend or zero-extend
     instruction for the shift count can be omitted.

`TRULY_NOOP_TRUNCATION (OUTPREC, INPREC)'
     A C expression which is nonzero if on this machine it is safe to
     ``convert'' an integer of INPREC bits to one of OUTPREC bits (where
     OUTPREC is smaller than INPREC) by merely operating on it as if it had
     only OUTPREC bits.

     On many machines, this expression can be 1.

`NO_FUNCTION_CSE'
     Define this macro if it is as good or better to call a constant
     function address than to call an address kept in a register.

`STORE_FLAG_VALUE'
     A C expression for the value stored by a store-flag instruction
     (`sCOND') when the condition is true.  This is usually 1 or -1; it is
     required to be an odd number.

     Do not define `STORE_FLAG_VALUE' if the machine has no store-flag
     instructions.

`Pmode'
     An alias for the machine mode for pointers.  Normally the definition
     can be

          #define Pmode SImode

`FUNCTION_MODE'
     An alias for the machine mode used for memory references to functions
     being called, in `call' RTL expressions.  On most machines this should
     be `QImode'.

`CONST_COST (X, CODE)'
     A part of a C `switch' statement that describes the relative costs of
     constant RTL expressions.  It must contain `case' labels for
     expression codes `const_int', `const', `symbol_ref', `label_ref' and
     `const_double'.  Each case must ultimately reach a `return' statement
     to return the relative cost of the use of that kind of constant value
     in an expression.  The cost may depend on the precise value of the
     constant, which is available for examination in X.

     CODE is the expression code---redundant, since it can be obtained with
     `GET_CODE (X)'.

`DOLLARS_IN_IDENTIFIERS'
     Define this if the character `$' should be allowed in identifier names.


File: internals,  Node: Condition Code,  Next: Assembler Format,  Prev: Misc,  Up: Machine Macros

Condition Code Information
==========================

The file `conditions.h' defines a variable `cc_status' to describe how the
condition code was computed (in case the interpretation of the condition
code depends on the instruction that it was set by).  This variable
contains the RTL expressions on which the condition code is currently
based, and several standard flags.

Sometimes additional machine-specific flags must be defined in the machine
description header file.  It can also add additional machine-specific
information by defining `CC_STATUS_MDEP'.

`CC_STATUS_MDEP'
     C code for a data type which is used for declaring the `mdep'
     component of `cc_status'.  It defaults to `int'.

`CC_STATUS_MDEP_INIT'
     A C expression for the initial value of the `mdep' field.  It defaults
     to 0.

`NOTICE_UPDATE_CC (EXP)'
     A C compound statement to set the components of `cc_status'
     appropriately for an insn whose body is EXP.  It is this macro's
     responsibility to recognize insns that set the condition code as a
     byproduct of other activity as well as those that explicitly set
     `(cc0)'.

     If there are insn that do not set the condition code but do alter
     other machine registers, this macro must check to see whether they
     invalidate the expressions that the condition code is recorded as
     reflecting.  For example, on the 68000, insns that store in address
     registers do not set the condition code, which means that usually
     `NOTICE_UPDATE_CC' can leave `cc_status' unaltered for such insns. 
     But suppose that the previous insn set the condition code based on
     location `a4@(102)' and the current insn stores a new value in `a4'. 
     Although the condition code is not changed by this, it will no longer
     be true that it reflects the contents of `a4@(102)'.  Therefore,
     `NOTICE_UPDATE_CC' must alter `cc_status' in this case to say that
     nothing is known about the condition code value.

